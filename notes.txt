Everything in javascript happens inside an execution context, execution context is like a big box and it has two components in it.The first component is also knows as the memory component, so this is the place wherer all the variables and functions are stored as key-value pairs. if suppose we have a variable "a" which is equivalent to 10, it will be stored over here and also functions also stored in this memory component, memory components also known as variable environment
The second component of this execution context is the code component, so this the place where code is executed one line at a time,it is also known as thread of execution, i repeat, thread of execution.
Javascript is a synchronous single-threaded language
invoke a function:
wheneve you see a function name,with these parantheses, it means that the function is now being executed.
a brand new execution context inside this is created,
1st phase is memory creation,dont forget that the memory is allocated to variables and functions inside this function. variables is undefined in phase1.
2nd phone is the code execution phase, in this we'll be executing each line here
return: keyword states that, now return the control of the program, to the place where this function was invoked

var n = 2;
function square (num){
  var ans = num * num;
  return ans;
}
var square2 = square(n);
var square4 = square(4);

it manages a stack this is known as the call stack, it has its own stack.
what is a call stack: the call stack is a stack in the bottom of the stack we have our global execution contaxt, that means whenever any js program is run, this call tack is populated with this global execution context. this whole execution context is pushed inside this stack, whenever a function is invoked, or a new execution content is created, so this execution context is put inside the stack.

whenever an execution context is created it is pushed into the stack, and whenever an execution context is deleted, it will move out of the stack.

"Call stack maintains the order of executio of execution contexts"
call stack is also known by very fancy names. there are lot of fancy names which you will see on web,
-- exection context stack
-- program stack
-- control stack
-- runtime stack
-- machine stack


variables & functions:-

Hoisting in javascript:
Hoisting is javascript which you can access these variables and functions even before you have initialized it and you have put same values in it you can access it without any errors
working example:
  var x = 7;
      function getName() {
        console.log("glad it works");
      }
      getName();
      console.log(x);


difrence between defined an undefined:-

undefined:-
even before code run its store the memory to variable, and if its function its store the whole function to memory.
not defined: 
if variable is not prasent or removed its shows the error not defined before its not even in memory.

undefined vs not defined
var a = 7;
even before this code run javascript reserved a memory to variable a its like a placeholder its undefined.
undefined is not equl to empty
not defined
console.log(x);
if we try to run this code it will give us an error that x is not defined. because we have not allocated memory to x
javascript is loosly type language

if function are arrow function

when get name is an arrow function its behaves just like an variable
   var getName = () => {
        console.log("glad it works");
      }

its says that getName is not a function
when memory allocation phase of the execution contact it will allocate the memories with a place holder undefined.

one more way to declare of function:-
var getName2 = function(){

}

its also behaves like an variable


Function invocation and variable environment:-
var x = 1;
a();
b();
console.log(x);

 function a() {
        var x = 10;
        console.log(x);
      }
      function b() {
        var x = 100;
        console.log(x);
      }

when code run global execution contaxt created, 1st line run 1st phase in memory contect x is undefined then in second phase x value is 1, after that 2 line run and a new execution context is created and function a is added in call stack, x value is undefined in 1st phase then in 2nd phase x value is 10 and print the value of x that is 10 then x pop out from stack. and execution context is deleted.

after that 3 line run and a new execution context is created and function b is added in call stack, x value is undefined in 1st phase then in 2nd phase x value is 100 and print the value of x that is 100 then x pop out from stack. and execution context is deleted.

at 4th line x value is printed as 1.


window & this keyword:-
shortest js program even js file is empty.
if we write window in console its shows an object with lots of functions and objects,these functions and variables is created by javascript engine, and into the global space you can access all the variables and functions anywhere in javascript program, ths functioality is givien by javascript engine.
javascript also create THIS key word, this points to window object.
window is a globel object which is created a long with the global education contact

globel space:-
any code you write in javascript which is not inside a function is called globl space, these variables or functions attached to window object.
var a = 10;
using glogel space
console.log(window.a);
console.log(this.a); // its also so tha same thing
and this automatically assume that you are referring to global space 
console.log(a);

whenever we try to access variavles and functions in program and we dont put anything in front of it, its assume that its in globel space.


// ? scope & lexical environment:-
function a() {
  var b = 10;
  c();
  function c() {}
}

a();
console.log(b);
// defination of scope
// * scope means where you can access specific variable or a function in our code that is scope
// there are 2 expect,
// 1st is, what is the scope of this variable:-
// example:-
// where i can access this variable b, is b inside the scope of function c, that means can i access b inside c.
// so there are 2 ways to look at it
// ? what is the scope of the variable
// ? is b inside the scope of function c

//scope is directly dependent of lexical environment
// when run program u know the globel excecution context is created and its push inside call stack

// ? whenever execution context is created a lexical environment is also cerated

// * so lexical environment is the local memory along with the lexical environment of its parent

// ? what is lexical:-
// lexical in a term means hierarchy or in a sequence

// example:-
//  c function is lexicaly siting inside a function

// scope chain:-

function a() {
  var b = 10;
  c();
  function c() {
    console.log(b);
  }
}

a();
console.log(b);

// ! when javascript encounter this line  console.log(b); inside c funtion its try to find the b inside the local memory of C, it won't find there because b is not in the local memory,now javascript engine gose to this refrance and gose to the lexical enmernment of this perent (so lexical means where it is lexical or physicaly prasent in the code so c is phicicaly prasent in a so c phycicaly perant is a so it will go to the lexical envernment of a ) so not it will try to search b inside the lexical envernment of a it find out b inside a so its goee back and its print of b inside the console.

// ? this whole process is called scope chain.
// * scope chain is nothing but this chain of all the lexical envernment and the perant refrances this is what the scope is.

// ? What is a Temporal Dead Zone:-

// *temporal dead zone is the time since when this let variable was hoisted and till its initilize some values the time between that is called or know as temporal dead zone.

// whenever you try to acsess a variable inside a temporal dead zone it gives you a refrance error
//error name : cannot access 'a' before initiaalization
// when the variables are in temporal dead zone you can not access them.they can only be access once some values innitallize to them.

// ? are let & const declarations hoisted?
// these let and const declarations are not hoisted that whould be incorect, thses are in the temporal dead zone for the time being.

let a = 10;
console.log(a);
var b = 100;

// in case of let and const they are allocatted memory they are also allocatted memory and that is what called hoisted,but they are stored in a different memory space then globel, they are not only globel object now they are stored in a saprate memory space and you can not accsess this memory space you can not asscess let and const decrarations before you have putting some value to them.

// let is more strict then var there is one more strictness level that we can not do re declarations

// example:-

let a = 10;
let a = 100;

// its throws a syntax Error so it's not even read a single line.

// it's possible in var but not possible in let

// ? const
// its behaves very much same to let, but there are differences it is even more strict then let.
// we have to initialize in same line, we can not initialize later.
let a = 10;
const b = 1000;

// ?  syntax Error

let a = 1900;

const b;

// it will give an error SyntaxError: missing initializer in const declaration, because here we have missing syntax its acpect that we have to give value.

// ? reference Error vs.

// when javascript engine tries to find out a specific variable inside the memory space and you can not access it, then its gives a refrance error.

console.log(a);
let a = 1900;

// ?  Type Error

const b = 1000;
b = 100000;

// ! its gives and error TypeError: Assignment to constant variable. becouse its a const type variable, we can not declare variavle later we have to initialize in same line.


// which variable should we used 
// high praority const 
// beucase you can not change this later
// then let
// beucase let have temporal dead zone and you will not runinto unexpecte error
// don't use var now ( some time we might have to use this but use it very consuanly )

// temporal dead zone can some time mess our life as developer also, it can lead to lots of unexpected errors so the best way to avoid these temporal dead zone is to always put your initialization and declaration on top


// ? block scope & shadowing

//? BLOCK
// block is defined by these curly braces, block is also known as compond statment. block is used to combain multiply javascript statment into one group
// example
// {
//   var a = 10;
//   console.log(a);
// }
// we group multiple statment togather in a block so that we can use it where javascript expect one statment.

// if (true) {
//   var a = 10;
//   console.log(a);
// }

// ? BLOCK SCOPE
// Block scope means what all variables and functions we can access inside this block
// {
//   var a = 10;
//   let b = 20;
//   const c = 30;
//   console.log(a);
//   console.log(b);
//   console.log(c);
// }

// console.log(a);
// console.log(b);
// console.log(c);

// out side of block b and c console not print because let and const are block scope.

// ? Shadowing
// if you have same name variable out side this block so inside variavle shadows that variable.
// shadowing is also works in functions is well as same as block
// var a = 100
// {
//   var a = 10;
//   let b = 20;
//   const c = 30;
//   console.log(a);
//   console.log(b);
//   console.log(c);
// }
// console.log(a);

// block variable was shadows and its also modified the value of outer variable, becuase they are points on same memory location.

// ! in case of let & const its diffrent
// the variable b which was outside of block (in script not even in globel) and another b whcih is inside the block
// here we have three type of scope 1st is globel scope 2nd is script 3 is block scope
// let b = 100;
// {
//   var a = 10;
//   let b = 20;
//   const c = 30;
//   console.log(a);
//   console.log(b);
//   console.log(c);
// }
// console.log(b);

//? illegal shadowing

// if you want to shadowing let a variable inside a block using a var you can not do that
// but var outside and let inside a scope will work
// ! but its valid if you do with let outside and let inside or var outside and var inside the scope

// let a = 20;
// {
//   var a = 20;
// }

// ? arrow functions
// Whether you declare a function with the function keyword or arrow functions, we feel that those might have different scopes, but they are exactly the same. All the scope rules that work on functions are exactly the same in arrow functions as well.
