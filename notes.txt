Everything in javascript happens inside an execution context, execution context is like a big box and it has two components in it.The first component is also knows as the memory component, so this is the place wherer all the variables and functions are stored as key-value pairs. if suppose we have a variable "a" which is equivalent to 10, it will be stored over here and also functions also stored in this memory component, memory components also known as variable environment
The second component of this execution context is the code component, so this the place where code is executed one line at a time,it is also known as thread of execution, i repeat, thread of execution.
Javascript is a synchronous single-threaded language
invoke a function:
wheneve you see a function name,with these parantheses, it means that the function is now being executed.
a brand new execution context inside this is created,
1st phase is memory creation,dont forget that the memory is allocated to variables and functions inside this function. variables is undefined in phase1.
2nd phone is the code execution phase, in this we'll be executing each line here
return: keyword states that, now return the control of the program, to the place where this function was invoked

var n = 2;
function square (num){
  var ans = num * num;
  return ans;
}
var square2 = square(n);
var square4 = square(4);

it manages a stack this is known as the call stack, it has its own stack.
what is a call stack: the call stack is a stack in the bottom of the stack we have our global execution contaxt, that means whenever any js program is run, this call tack is populated with this global execution context. this whole execution context is pushed inside this stack, whenever a function is invoked, or a new execution content is created, so this execution context is put inside the stack.

whenever an execution context is created it is pushed into the stack, and whenever an execution context is deleted, it will move out of the stack.

"Call stack maintains the order of executio of execution contexts"
call stack is also known by very fancy names. there are lot of fancy names which you will see on web,
-- exection context stack
-- program stack
-- control stack
-- runtime stack
-- machine stack


variables & functions:-

Hoisting in javascript:
Hoisting is javascript which you can access these variables and functions even before you have initialized it and you have put same values in it you can access it without any errors
working example:
  var x = 7;
      function getName() {
        console.log("glad it works");
      }
      getName();
      console.log(x);


difrence between defined an undefined:-

undefined:-
even before code run its store the memory to variable, and if its function its store the whole function to memory.
not defined: 
if variable is not prasent or removed its shows the error not defined before its not even in memory.


if function are arrow function

when get name is an arrow function its behaves just like an variable
   var getName = () => {
        console.log("glad it works");
      }

its says that getName is not a function
when memory allocation phase of the execution contact it will allocate the memories with a place holder undefined.

one more way to declare of function:-
var getName2 = function(){

}

its also behaves like an variable


Function invocation and variable environment:-
var x = 1;
a();
b();
console.log(x);

 function a() {
        var x = 10;
        console.log(x);
      }
      function b() {
        var x = 100;
        console.log(x);
      }

when code run global execution contaxt created, 1st line run 1st phase in memory contect x is undefined then in second phase x value is 1, after that 2 line run and a new execution context is created and function a is added in call stack, x value is undefined in 1st phase then in 2nd phase x value is 10 and print the value of x that is 10 then x pop out from stack. and execution context is deleted.

after that 3 line run and a new execution context is created and function b is added in call stack, x value is undefined in 1st phase then in 2nd phase x value is 100 and print the value of x that is 100 then x pop out from stack. and execution context is deleted.

at 4th line x value is printed as 1.


window & this keyword:-
shortest js program even js file is empty.
if we write window in console its shows an object with lots of functions and objects,these functions and variables is created by javascript engine, and into the global space you can access all the variables and functions anywhere in javascript program, ths functioality is givien by javascript engine.
javascript also create THIS key word, this points to window object.
window is a globel object which is created a long with the global education contact

globel space:-
any code you write in javascript which is not inside a function is called globl space, these variables or functions attached to window object.
var a = 10;
using glogel space
console.log(window.a);
console.log(this.a); // its also so tha same thing
and this automatically assume that you are referring to global space 
console.log(a);

whenever we try to access variavles and functions in program and we dont put anything in front of it, its assume that its in globel space.
